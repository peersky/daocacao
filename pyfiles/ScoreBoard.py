# Code generated by moonworm : https://github.com/bugout-dev/moonworm
# Moonworm version : 0.1.12

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from brownie import Contract, network, project
from brownie.network.contract import ContractContainer
from eth_typing.evm import ChecksumAddress


PROJECT_DIRECTORY = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
BUILD_DIRECTORY = os.path.join(PROJECT_DIRECTORY, "build", "contracts")


def boolean_argument_type(raw_value: str) -> bool:
    TRUE_VALUES = ["1", "t", "y", "true", "yes"]
    FALSE_VALUES = ["0", "f", "n", "false", "no"]

    if raw_value.lower() in TRUE_VALUES:
        return True
    elif raw_value.lower() in FALSE_VALUES:
        return False

    raise ValueError(
        f"Invalid boolean argument: {raw_value}. Value must be one of: {','.join(TRUE_VALUES + FALSE_VALUES)}"
    )


def bytes_argument_type(raw_value: str) -> bytes:
    return raw_value.encode()


def get_abi_json(abi_name: str) -> List[Dict[str, Any]]:
    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    abi_json = build.get("abi")
    if abi_json is None:
        raise ValueError(f"Could not find ABI definition in: {abi_full_path}")

    return abi_json


def contract_from_build(abi_name: str) -> ContractContainer:
    # This is workaround because brownie currently doesn't support loading the same project multiple
    # times. This causes problems when using multiple contracts from the same project in the same
    # python project.
    PROJECT = project.main.Project("moonworm", Path(PROJECT_DIRECTORY))

    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    return ContractContainer(PROJECT, build)


class ScoreBoard:
    def __init__(self, contract_address: Optional[ChecksumAddress]):
        self.contract_name = "ScoreBoard"
        self.address = contract_address
        self.contract = None
        self.abi = get_abi_json("ScoreBoard")
        if self.address is not None:
            self.contract: Optional[Contract] = Contract.from_abi(
                self.contract_name, self.address, self.abi
            )

    def deploy(self, transaction_config):
        contract_class = contract_from_build(self.contract_name)
        deployed_contract = contract_class.deploy(transaction_config)
        self.address = deployed_contract.address
        self.contract = deployed_contract

    def assert_contract_is_instantiated(self) -> None:
        if self.contract is None:
            raise Exception("contract has not been instantiated")

    def decrese_score(
        self, participant: ChecksumAddress, value: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.decreseScore(participant, value, transaction_config)

    def increse_score(
        self, participant: ChecksumAddress, value: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.increseScore(participant, value, transaction_config)

    def owner(self) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.owner.call()

    def participants(self, arg1: ChecksumAddress) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.participants.call(arg1)

    def read_score_board(self) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.readScoreBoard.call()

    def read_test(self, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.readTest(transaction_config)

    def register_participant(
        self, new_participant: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.registerParticipant(new_participant, transaction_config)

    def renounce_ownership(self, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.renounceOwnership(transaction_config)

    def reset_scores(self, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.resetScores(transaction_config)

    def transfer_ownership(self, new_owner: ChecksumAddress, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.transferOwnership(new_owner, transaction_config)

    def update_score(
        self, participant: ChecksumAddress, new_score: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.updateScore(participant, new_score, transaction_config)


def get_transaction_config(args: argparse.Namespace) -> Dict[str, Any]:
    signer = network.accounts.load(args.sender, args.password)
    transaction_config: Dict[str, Any] = {"from": signer}
    if args.gas_price is not None:
        transaction_config["gas_price"] = args.gas_price
    if args.confirmations is not None:
        transaction_config["required_confs"] = args.confirmations
    if args.nonce is not None:
        transaction_config["nonce"] = args.nonce
    return transaction_config


def add_default_arguments(parser: argparse.ArgumentParser, transact: bool) -> None:
    parser.add_argument(
        "--network", required=True, help="Name of brownie network to connect to"
    )
    parser.add_argument(
        "--address", required=False, help="Address of deployed contract to connect to"
    )
    if not transact:
        return
    parser.add_argument(
        "--sender", required=True, help="Path to keystore file for transaction sender"
    )
    parser.add_argument(
        "--password",
        required=False,
        help="Password to keystore file (if you do not provide it, you will be prompted for it)",
    )
    parser.add_argument(
        "--gas-price", default=None, help="Gas price at which to submit transaction"
    )
    parser.add_argument(
        "--confirmations",
        type=int,
        default=None,
        help="Number of confirmations to await before considering a transaction completed",
    )
    parser.add_argument(
        "--nonce", type=int, default=None, help="Nonce for the transaction (optional)"
    )


def handle_deploy(args: argparse.Namespace) -> None:
    network.connect(args.network)
    transaction_config = get_transaction_config(args)
    contract = ScoreBoard(None)
    result = contract.deploy(transaction_config=transaction_config)
    print(result)


def handle_decrese_score(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.decrese_score(
        participant=args.participant,
        value=args.value,
        transaction_config=transaction_config,
    )
    print(result)


def handle_increse_score(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.increse_score(
        participant=args.participant,
        value=args.value,
        transaction_config=transaction_config,
    )
    print(result)


def handle_owner(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    result = contract.owner()
    print(result)


def handle_participants(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    result = contract.participants(arg1=args.arg1)
    print(result)


def handle_read_score_board(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    result = contract.read_score_board()
    print(result)


def handle_read_test(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.read_test(transaction_config=transaction_config)
    print(result)


def handle_register_participant(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.register_participant(
        new_participant=args.new_participant, transaction_config=transaction_config
    )
    print(result)


def handle_renounce_ownership(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.renounce_ownership(transaction_config=transaction_config)
    print(result)


def handle_reset_scores(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.reset_scores(transaction_config=transaction_config)
    print(result)


def handle_transfer_ownership(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.transfer_ownership(
        new_owner=args.new_owner, transaction_config=transaction_config
    )
    print(result)


def handle_update_score(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = ScoreBoard(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.update_score(
        participant=args.participant,
        new_score=args.new_score,
        transaction_config=transaction_config,
    )
    print(result)


def generate_cli() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="CLI for ScoreBoard")
    parser.set_defaults(func=lambda _: parser.print_help())
    subcommands = parser.add_subparsers()

    deploy_parser = subcommands.add_parser("deploy")
    add_default_arguments(deploy_parser, True)
    deploy_parser.set_defaults(func=handle_deploy)

    decrese_score_parser = subcommands.add_parser("decrese-score")
    add_default_arguments(decrese_score_parser, True)
    decrese_score_parser.add_argument(
        "--participant", required=True, help="Type: address"
    )
    decrese_score_parser.add_argument(
        "--value", required=True, help="Type: uint256", type=int
    )
    decrese_score_parser.set_defaults(func=handle_decrese_score)

    increse_score_parser = subcommands.add_parser("increse-score")
    add_default_arguments(increse_score_parser, True)
    increse_score_parser.add_argument(
        "--participant", required=True, help="Type: address"
    )
    increse_score_parser.add_argument(
        "--value", required=True, help="Type: uint256", type=int
    )
    increse_score_parser.set_defaults(func=handle_increse_score)

    owner_parser = subcommands.add_parser("owner")
    add_default_arguments(owner_parser, False)
    owner_parser.set_defaults(func=handle_owner)

    participants_parser = subcommands.add_parser("participants")
    add_default_arguments(participants_parser, False)
    participants_parser.add_argument("--arg1", required=True, help="Type: address")
    participants_parser.set_defaults(func=handle_participants)

    read_score_board_parser = subcommands.add_parser("read-score-board")
    add_default_arguments(read_score_board_parser, False)
    read_score_board_parser.set_defaults(func=handle_read_score_board)

    read_test_parser = subcommands.add_parser("read-test")
    add_default_arguments(read_test_parser, True)
    read_test_parser.set_defaults(func=handle_read_test)

    register_participant_parser = subcommands.add_parser("register-participant")
    add_default_arguments(register_participant_parser, True)
    register_participant_parser.add_argument(
        "--new-participant", required=True, help="Type: address"
    )
    register_participant_parser.set_defaults(func=handle_register_participant)

    renounce_ownership_parser = subcommands.add_parser("renounce-ownership")
    add_default_arguments(renounce_ownership_parser, True)
    renounce_ownership_parser.set_defaults(func=handle_renounce_ownership)

    reset_scores_parser = subcommands.add_parser("reset-scores")
    add_default_arguments(reset_scores_parser, True)
    reset_scores_parser.set_defaults(func=handle_reset_scores)

    transfer_ownership_parser = subcommands.add_parser("transfer-ownership")
    add_default_arguments(transfer_ownership_parser, True)
    transfer_ownership_parser.add_argument(
        "--new-owner", required=True, help="Type: address"
    )
    transfer_ownership_parser.set_defaults(func=handle_transfer_ownership)

    update_score_parser = subcommands.add_parser("update-score")
    add_default_arguments(update_score_parser, True)
    update_score_parser.add_argument(
        "--participant", required=True, help="Type: address"
    )
    update_score_parser.add_argument(
        "--new-score", required=True, help="Type: uint256", type=int
    )
    update_score_parser.set_defaults(func=handle_update_score)

    return parser


def main() -> None:
    parser = generate_cli()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
